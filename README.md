# 高并发点赞系统设计

## 1.0
目前使用到的技术栈有springboot3 + mybatis-plus + 声明式事务 + redisson分布式锁 + mysql + knife4j

基础实现用户、点赞、博客等功能

## 2.0
1.引入 spring-session 可以实现分布式登录态，存30分钟

2.利用 jedis + spring-boot-starter-data-redis 实现登录态的持久化存储、使用redis的hash结构替换点赞判断逻辑，减轻数据库压力

### 冷热数据分离拓展：
1.定义存储结构

2.设置值，点赞记录id加上过期时间戳

3.判断是否为blog 的创建时间是否在“一个月前”这个时间点之后。 查询hash结构的数据，不是的话，值为null就代表没有点过赞， 使用instanceof结构类型，比较当前时间和过期，如果大于就使用jdk21特性虚拟线程Thread.ofVirtual().start(执行删除hash操作) 返回false;没有过期并且又是存在的, 返回true

4.不在一个月内，就是mybatis-plus的exist查询返回结果

## 3.0
为了提升性能，使用Redis临时点赞数据，加定时任务落库 + 补偿操作

1.引入了lua脚本替代掉同步锁和事务,复杂逻辑迁移

2.新编写了redis实现的点赞服务，通过不同的服务名称注入

3.新增了定时任务，按顺序执行 点赞(新增记录)，再取消点赞(移除记录)，博客点赞数(更新)

4.使用虚拟线程异步删除这个时间片内的所有redis数据

5.异步化定时任务操作，解决任务阻塞的问题

## 4.0
为了解决以下两个问题： 单点热点问题和恶意用户刷接口

1.引入caffeine来构建多级缓存框架，进一步提升性能, 
多级缓存框架：(L1)Caffeine + (L2)Redis + (L3)MySQL.

2.根据网上的例子实现HeavyKeeper算法, 来检测热点Key，为热点数据，就缓存到本地数据中提高性能

## 5.0 
虽然已经基于Redis、Caffeine和定时任务构建了高性能的点赞系统。

但是目前存在问题以下几个问题：

1.点赞操作与后续的数据处理(如计数更新、消息通知)强耦合，不利于功能扩展。

2.Redis和数据库之间数据同步依赖定时任务，缺乏实时性和可靠性保障。

引入消息队列pulsar，对系统进行异步化构造处理，提高系统削峰填谷能力和系统可用性。

具体设计分为三个部分：

1.用户进行点赞/取消点赞，执行lua脚本判断点赞状态，返回失败则不需要继续处理，成功就构造点赞事件发送到消息队列中，
如果发送成功就返回true，否则回滚Redis的状态，保证数据一致性。

2.下游消费者消息处理，批量消费1000条/10秒，数据库持久化，如果成功了，就自动ack消息，失败了进行3次重试，
重试还是失败，就放入死信队列进行响应的逻辑处理

3.最终一致性保障(对账机制)，分别从redis和mysql取出数据，借助guava库的Sets.difference方法获得差异的博客数据，
发送补偿消息事件